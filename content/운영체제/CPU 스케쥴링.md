## CPU 스케쥴링

CPU 스케줄러는 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일을 말한다.



### 스케줄링의 단계



CPU 스케쥴링은 규모에 따라 고수준 스케쥴링 , 중간 수준 저수준으로 구분된다.

![쉽게 배우는 운영체제 4장 : CPU 스케줄링 (1/2) [OS]](D:\SSAFY\CS-Study-taegyu\content\운영체제\img\123123.png)



#### 고수준 스케줄링



고수준 스케쥴링 : 시스템 내의 전체 작업수를 조절 하는 것 , 시스템이 시작 되면 시스템 자원을 사용하기 때문에 기존 작업에 영향을 미친다. 작업 요청이 오면 스케줄러가 시스템의 상황을 고려하여 작업을 승인할지, 거부할지를 결정하므로 고수준 스케줄링을 승인 스케줄링이라고도 한다.



#### 저수준 스케줄링

저수준 스케줄링은 어떤 프로세스에 CPU를 할당할지 , 어떤 프로세스를 대기 상태로 보낼지 결정한다.

- 준비 상태에 있는 프로세스를 실행 상태로 보내고 실행 상태에 있는 프로세스를 대기 상태로 보내는 등의 간단한 스케줄링 작업을 수행한다.



#### 중간 수준 스케줄링 

저수준과 고수준 사이에 일어나는 스케줄링이다. 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부화를 막는다.



### 스케줄링의 목적



**CPU 스케줄링의 목적**

공평성 : 특정 프로세스가 배제되어서는 안됨

효율성 : 유휴 시간 없이 사용되도록
 안정성 : 중요 프로세스가 먼저 작동, 시스템 자원을 무단/과도하게 점유 하려는 프로세스로부터 자원 보호
 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록
반응 시간 보장 : 적절한 시간 안에 프로세스의 요구에 반응해야 함
 무한 연기 방지 : 무한히 연기 되어서는 안됨(배제X)



## 스케줄링 시 고려 사항



- 선점형 스케줄링 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
- 비선점형 스케줄링: 뺏을수 없는 스케줄링 방식



| 구분      | 선점형                                                       | 비선점형                                                     |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 작업 방식 | 실행 상태에 있는 작업을 중단시키고 새로운 작업을 실행할 수 있다. | 실행 상태에 있는 작업이 완료될 때까지 다른 작업이 불가능하다 |
| 장점      | 프로세스가 CPU를 독점 할 수 없어 대화형이나 시분할 시스템에 적합 | 작업량이 적고 컨텍스트 스위칭 오버헤드가 적다.               |
| 단점      | 컨텍스트 스위칭 오버헤드가 많다                              | 기다리는 프로세스가 많아 처리율이 떨어진다                   |
| 사용      | 시분할 방식 스케줄러                                         | 일괄 작업 방식 스케줄러                                      |
| 중요도    | 높다                                                         | 낮다                                                         |



#### CPU 집중 프로세스와 입출력 집중 프로세스

프로세스는 CPU를 사용하여 작업을 하는 실행 상태 또는 입출력을 요청하여 완료되기까지 기다리는 대기 상태에 있다.이 때 CPU를 할당받아 실행하는 작업을 CPU burst , 입출력 작업을 입출력 burst라고 부른다.



1. CPU 집중 프로세스: CPU 많이 사용하는 프로세스(수학 연산)

2. 입출력 집중 프로세스: 입출력을 많이 사용하는 프로세스(저장장치에서 데이터 복사)



![img](https://velog.velcdn.com/images%2Ftnwls2%2Fpost%2F2816a54c-8a02-4b57-ac69-913aeef9dff6%2Fimage.png)



입출력 집중 프로세스를 CPU 집중 프로세스보다 먼저 두는것이 낫다.



## 스케줄링  알고리즘 



![img](https://velog.velcdn.com/images%2Ftnwls2%2Fpost%2Ffd7bc47b-fd4e-4adf-b84a-9a25b8a61442%2Fimage.png)



### 스케줄링 알고리즘의 선택 기준

- CPU 사용률 : 전체 시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법이다.
- 처리량: 시스템이 정상적으로 작동한다
- 대기시간 : 작업을 요청 하더라도 실제 작업이 이루어지기 전까지는 대기 시간이 필요하다. 대기 시간은 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간
- 응답 시간 :  응답 시간은 프로세스 시작후 첫 번째 출력 또는 반응이 올때까지의 시간으로 짧을 수록 좋다.
- 반환 시간 : 대기시간 실행 시간 

![img](D:\SSAFY\CS-Study-taegyu\content\운영체제\img\images%2Ftnwls2%2Fpost%2Fc44d040e-1be2-47ba-ac7e-0ad357ae4c58%2Fimage.png)

스케줄링 알고리즘의 성능을 비교할 때는 주로 평균 대기 시간을 본다.



## FCFS 스케줄링

First come First served 스케줄링은 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식



#### 성능

평균 대기 시간은 작업이 시작할때까지 전체 프로세스가 대기한 시간의 평균 값



| 도착 순서 | 도착 시간 | 작업 시간 |
| --------- | --------- | --------- |
| P1        | 0         | 30        |
| P2        | 3         | 18        |
| P3        | 6         | 9         |

P1의 대기시간 = 0

P2의 대기시간 = P1의 작업시간 - 도착시간 = 27

P3의 대기시간 = P2의 작업이 끝날떄까지의 시간 - 도착시간 = 42

평균 대기 시간은 69 / 3 = 23 이다

FCFS 스케줄링은 쉽고 공평하지만 처리 시간이 긴 프로세스가 CPU를 점유하면 계속 기다려야하는데 이러한 현상을 콘보이 효과라고 한다.

FCFS 스케줄링 방식은 입출력을 요구 했을때 작업 효율이 떨어진다.



## SJF 스케줄링

shortest job first 스케줄링 방식은 준비 큐에 있는 프로세스 중에 실행시간이 가장 짧은 작업 부터 CPU를 할당하는 비선점형 방식

SJF 스케줄링은 프로세스에 CPU를 배정할 때 시간이 오래 걸리는 작업이 앞에 있고 간단한 작업이 뒤에 있으면 순서를 바꾸어 실행한다.



#### 성능

| 도착 순서 | 도착 시간 | 작업 시간 |
| --------- | --------- | --------- |
| P1        | 0         | 30        |
| P2        | 3         | 18        |
| P3        | 6         | 9         |

P1의 대기시간 = 0

P3의 대기시간 = P1의 작업시간 - 도착시간 = 24

P2의 대기시간 = P3의 작업이 끝날떄까지의 시간 - 3 = 36



SJF 스케줄링의 평균 대기시간은 20이다



SJF 스케줄링의 단점 

- 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다. 현대의 프로세스는 사용자와 상호작용이 빈번하기 때문에 프로그램 종료시간을 파악하기 힘들다.
- 프로세스 P2 는 P3보다 일찍 도착했지만 가장 나중에 실행되었다. 만약 P3과 같은 작업이 큐에 계속 들어오면 P2의 작업이 연기 되는데 이를 아사 현상이라고 한다.



#### 해결 방법

1. 프로세스가 자신의 작업 시간을 운영체제에 알려준다.
2. 에이징으로 완화한다. 에이징은 프로세스가 양보할 수 있는 상한선을 정한다.



SJF는 프로세스의 종료시간을 파악하기 어렵고 아사 현상때문에 잘 사용하지 않는다.



### HRN 스케줄링

Highest Response ratio Next 스케줄링은 아사 현상을 해결하기 위해 만들어진 비선점형 스케줄링 방식이다.

HRN은 서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려하여 스케줄링을 하는 방식이다.


$$
우선순위 = (대기시간 + CPU 사용시간 )/ CPU 사용 시간
$$
SJF 방식에 에이징을 구현한 방식이다. 

| 도착 순서 | 도착 시간 | 작업 시간 |
| --------- | --------- | --------- |
| P1        | 0         | 30        |
| P2        | 3         | 18        |
| P3        | 6         | 9         |

P1의 대기시간 = 0

P1이 빠지면 P2와 P3의 우선순위를 계산한다.

P2의 우선순위 = 27 + 18 / 18 = 2.5

P3의 우선순위 = 24+9 / 9 =3.67이다. 따라서 P3이 먼저 실행된다.

SJf 스케줄링과 성능이 같다.



### 라운드 로빈 스케줄링

Round Robin 스케줄링은 프로세스가 할당받은 시간 동안 작업을 하다가 완료하지 못하면 준비 큐의 맨뒤로 가서 자기 차례를 기다린다.

할당 받은 작업 시간이 크면 FCFS와 같아지고 할당 받은 작업 시간이 너무 작다면 컨텍스트 스위칭이 너무 많이 일어나서 작업 시간보다 길어질수가 있다.

적절한 할당시간을 고려하는것이 중요하다.



### SRT 우선 스케줄링



Shortest Remaining Time 스케줄링은 SJf 스케줄링과 라운드로빈 스케줄링을 혼합한 방식이다.

SRT 스케줄링은 기본적으로 라운드로빈으로 돌아가지만, 할당받을 프로세스를 고를때 남아 있는 작업시간이 가장 적은 프로세스를 선택한다.

- 현재 실행중인 프로세스와 큐에 있는 프로세스의 남은 시간을 계산, 남은 시간이 더적은 프로세스와 컨텍스트 스위칭을 해야하는 SJf 스케줄링 에는 없는 작업이 추가된다.
- 마찬가지로 아사 현상이 일어난다.



###  우선순위 스케줄링

| 도착 순서 | 도착 시간 | 작업 시간 | 우선순위 |
| --------- | --------- | --------- | -------- |
| P1        | 0         | 30        | 3        |
| P2        | 3         | 18        | 2        |
| P3        | 6         | 9         | 1        |



P1은 바로 실행한다.

P1이 끝나면 큐에 P2 , P3이 있고 우선순위가 P3이 더 높기 때문에 P3이 먼저 실행된다.

우선순위는 비선점과 선점형 방식 모두 적용이 가능하다.

- SJF(비선점): 작업시간 짧은 프로세스 순
- HRN(비선점): 작업시간 짧거나 대기시간 긴 프로세스 순
- SRT(선점): 남은 시간이 짧은 순
- 고정 우선순위 알고리즘 : 우선순위를 부여받으면 종료될때까지 고정 시스템의 상황을 즉각적으로 반영하지 못해 효율성이 떨어짐
- 변동 우선순위 알고리즘: 일정 시간마다 우선순위가 변한다. 우선순위를 계산하는것이 복잡하다





### 다단계 큐 스케줄링

우선순위 에 따라 준비큐를 여러개 사용하는 방식이다.

![CPU Scheduling(스케줄링) - 다단계 큐 스케줄링, 다단계 피드백 큐 스케줄링, Fair-share 스케줄링, 실시간 스케줄링](D:\SSAFY\CS-Study-taegyu\content\운영체제\img\2562294456EA1BBE0C)



우선 순위는 고정형 우선순위를 사용한다.

- 우선 순위에 따라 할당 시간을 조절할수도 있다.
- 우선순위가 높은 큐의 작업이 끝나야 다음 큐의 작업이 시작된다.
- 우선순위가 높은 큐의 작업이 끝나기 전에는 하위 큐 프로세스의 작업을 할수가 없다.



### 다단계 피드백 큐 스케줄링



![img](D:\SSAFY\CS-Study-taegyu\content\운영체제\img\multilevel-feedback-queue-scheduling.png)

우선 순위가 낮은 프로세스에 불리한 스케줄링의 문제점을 보완한 ㅎ방식이다.

- 다단계 큐 스케줄링과 같이 여러 큐를 사용한다.
- 다단계 피드백 큐 스케줄링의 경우 cpu를 사용하면 우선순위가 낮아진다.
- cpu를 사용한 프로세스는 원래 큐로 돌아가지않고 우선순위가 하나 낮은 큐의 끝으로 들어간다.
- 우선순위에 따라 할당 시간이 다르다.
- 우선순위가 낮은 프로세스들은 좀 더 할당시간을 많이 부여받아 최대한 배려를 받는다.
- 오늘날의 스케줄링을 위해 일반적으로 사용하는 방식이다.