# TCP / IP

> 인터넷에서 컴퓨터들이 서로 정보를 주고 받는데 쓰이는 프로토콜의 집합



## TCP IP의 계층

![image-20220825175724753](D:\SSAFY\CS-Study-taegyu\content\네트워크\img\image-20220825175724753.png)

![image-20220825175950317](D:\SSAFY\CS-Study-taegyu\content\네트워크\img\image-20220825175950317.png)

 



- Application Layer :  애플리케이션 끼리 정보를 주고 받는것  ex)브라우저가 HTTP 요청을 통해 통신하는것

- Transport Layer : 포트 번호를 사용해서 애플리케이션을 찾는다.

- Internet layer : IP주소를 바탕으로 올바른 목적지를 찾는다.

- Network access layer : 물리적 주소인 Mac 주소를 사용해서 기기의 목적지를 찾는다.

  



# 신뢰성 있는 통신

- 현실의 통신은 이상적이지 않다.
- 패킷이 유실됌
- 무한히 흐르지 않는다.
- 패킷이 순서대로 오지가 않을 수 있다.
- 패킷이 변조 될 수 있다

![](https://images.velog.io/images/suker80/post/07b65f19-45df-48f1-9a89-7d2d532be360/image.png)

- 송신자는 패킷에 번호를 붙여서 보낸다
- 수신자는 받은 패킷에 대해서 응답에 번호를 붙여서 보낸다.
- 만약 타임아웃이 일어나면 응답을 받지 못한 패킷에 대해서 다시 재전송을 한다.
- 수신자는 같은 패킷이 중복해서 온것을 알아 낼 수가 있다.


## Pipeline 통신

> 연속된 대량의 작업이 순차성을 갖고 있으나 병렬적으로 수행할수 있는 경우 

![](https://images.velog.io/images/suker80/post/8dd7d3cc-9f0a-433f-8872-9723b4edaa17/image.png)

- 패킷을 순차적으로 보낸다
- 보내다가 어떠한 패킷에 대해서 유실이 된 경우 그 패킷부터 다시 순차적으로 전송한다.


### go - back -n 파이프라인

- N개의 패킷을 병렬적으로 처리

- 송신측에서는 N개의 패킷을 버퍼링(재전송하기 위해)
- 수신측에서는 순차적으로 잘 수신된 패킷에 대하여 Ack을 송신하고 패킷의 페이로드 응용계층으로 올려보낸다.
- 송신측에서는 버퍼에 여유가 생기면(ACk를 받을때마다) 패킷을 추가로 보낸다.

- 송신측에서 패킷을 잘 받으면 그 패킷 이전에 송신한 패킷은 수신측에서 잘 수신했다고 고려 할 수 있다.

#### 수신측에서 패킷이 순서에 맞지 않는 경우
- 가만히 있는다
- 잘 받은 마지막 패킷에 대해서 ack을 전송

#### 장점
- 단순
- 간편하게 시스템의 상태가 추상화
#### 단점
- 패킷 유실시 비용이 많이 든다.


### Selective repeat

![](https://images.velog.io/images/suker80/post/f91a5cdd-f0ac-40e7-8c8d-10f74091c8e6/image.png)

- 수신 측에도 버퍼를 둔다.
- 유실 된 패킷 이후에 받은 패킷들은 버퍼에 임시  저장 해둔다.
- 재 전송한 패킷이 수신측에 도착하면 버퍼에 저장한 패킷과 함께 응용층에 전송한다.

장점 : 
- 실패 한 패킷만 재전송
단점 : 
- 시스템 추상화 복잡
- 수신측에도 버퍼가 필요

## 혼잡 제어

### 혼잡 인지
 - 패킷 손실이 일어나면 네트워크가 혼잡 하다고 판단을 해 전송률을 낮춘다..
 - 패킷 손실이 일어나지 않으면 네트워크가 원할하다 판단을 해 전송률을 높인다.

 - 패킷 유실 : ack 신호가 타임아웃 시간안에 오지않음 

![](https://images.velog.io/images/suker80/post/0d693bd2-3c57-4134-a063-5f4f7c835438/image.png)

> Retransmission TimeOut = 재 전송까지 걸리는 타임 아웃
> Round Trip Time = 한 패킷이 보냈다가 돌아오는데 까지 걸리는 시간
 - ACK 타임아웃은 너무 길거나 짧지 않게 설정한다.

 RTO = (RTT(평균) + RTT 의 표준편차 *4, 1초) 중에 큰 값으로 정한다.

 > 위의 확률은 정규분포표에 따르면 약 1/10000의 확률이다

 ### RTT 구하기


 #### weighted moving average 
 - 최근에 구한 값에 더 가중지츨 둔 계산법

 RTTn = RTT의 n번째 측정값
 RTTm = m번째 샘플후 측정한 평균값 

 ![](https://images.velog.io/images/suker80/post/8944718e-7583-4ae1-90f9-31e42cd929b4/image.png)


 ### 혼잡 제어

 #### additive increase 

 단위 (Increase)
 	:MSS (Maximum Segment size)

- 보통 1~ 4 Kb로 정한다.
- 세그먼트의 크기는 효율의 문제
- 크다고 무조건 좋지는 않음( 세그먼트를 다시 쪼개야 하는 경우도 있다)
- 패킷이 정상적으로 통신이 되면 MSS 한개를 더 담아서 전송한다.
- 패킷을 하나씩 보내고 문제 없이 도착하면 윈도우의 크기를 증가시켜서 전송한다.

#### Multiplicative Decrease
- 만약 패킷 전송이 실패하면 패킷의 수를 절반으로 줄인다.
- 패킷 유실이 네트워크 이상을 반영할때는 Congestion Window를 1 Mss로 줄인다.
- 네트워크 이상시에는 Cw를 1로 줄인다.
- 단순 유실 경우에는 현재 Cw를 반으로 줄인다

#### Fast Transmit
- Ack을 보낼 때 마지막으로 받은 패킷 다음의 패킷의 순번을 담아서 보낸다
- 송신측에서 이 ACk을 연달아서 받게 되면 혼잡한 상황이라고 파악하고 창 크기를 줄인다
- 수신하지 못한 패킷을 다시 보내게 된다.

#### slow start
- 네트워크 이상시 Cw -> 1로 바뀌어서 cw증가가 느리다
  예) 기존 cw가 100일 경우 1/2 cw이 될때까지 선형적으로 증가시킨다.
  

![](https://images.velog.io/images/suker80/post/b351c6ca-5468-4686-8c0f-391f5d7cc267/image.png)

 



## 흐름제어

- 수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생긴다.
- 수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실 될 수 있으며, 만약 손실 된다면 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번이 발생한다.





## 흐름제어 해결 방법

Stop and Wait

![image-20220825201448665](D:\SSAFY\CS-Study-taegyu\content\네트워크\img\image-20220825201448665.png)

매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법.





### Sliding window

![img](https://t1.daumcdn.net/cfile/tistory/253F7E485715ED5F27)

수신측에서 설정한 윈도우 크기만큼 전송해서 데이터 흐름을 동적으로 조절하는 제어 기법

윈도우에 포함되는 패킷을 전송하고 전송이 확인이 되면 윈도우를 옆으로 옮겨서 다음 패킷 전송한다.



